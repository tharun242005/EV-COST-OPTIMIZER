import { StreamMetadata } from "./streamMetadata";
import { type PhysicalStreamType } from "./physicalStreamType";
import { type LogicalStreamType } from "./logicalStreamType";
import { type LogicalLevelTechnique } from "./logicalLevelTechnique";
import { type PhysicalLevelTechnique } from "./physicalLevelTechnique";
import type IntWrapper from "../../decoding/intWrapper";
export declare class RleEncodedStreamMetadata extends StreamMetadata {
    private readonly _runs;
    private readonly _numRleValues;
    /**
     * @param numValues After LogicalLevelTechnique was applied -> numRuns + numValues
     * @param _runs Length of the runs array
     * @param _numRleValues Used for pre-allocating the arrays on the client for faster decoding
     */
    constructor(physicalStreamType: PhysicalStreamType, logicalStreamType: LogicalStreamType, logicalLevelTechnique1: LogicalLevelTechnique, logicalLevelTechnique2: LogicalLevelTechnique, physicalLevelTechnique: PhysicalLevelTechnique, numValues: number, byteLength: number, _runs: number, _numRleValues: number);
    static decode(tile: Uint8Array, offset: IntWrapper): RleEncodedStreamMetadata;
    static decodePartial(streamMetadata: StreamMetadata, tile: Uint8Array, offset: IntWrapper): RleEncodedStreamMetadata;
    get runs(): number;
    get numRleValues(): number;
    /**
     * Override to return the decompressed count for RLE streams.
     */
    getDecompressedCount(): number;
}
