import { PhysicalStreamType } from "./physicalStreamType";
import { LogicalStreamType } from "./logicalStreamType";
import { LogicalLevelTechnique } from "./logicalLevelTechnique";
import { PhysicalLevelTechnique } from "./physicalLevelTechnique";
import { DictionaryType } from "./dictionaryType";
import { OffsetType } from "./offsetType";
import { LengthType } from "./lengthType";
import { decodeVarintInt32 } from "../../decoding/integerDecodingUtils";
export class StreamMetadata {
    _physicalStreamType;
    _logicalStreamType;
    _logicalLevelTechnique1;
    _logicalLevelTechnique2;
    _physicalLevelTechnique;
    _numValues;
    _byteLength;
    constructor(_physicalStreamType, _logicalStreamType, _logicalLevelTechnique1, _logicalLevelTechnique2, _physicalLevelTechnique, _numValues, _byteLength) {
        this._physicalStreamType = _physicalStreamType;
        this._logicalStreamType = _logicalStreamType;
        this._logicalLevelTechnique1 = _logicalLevelTechnique1;
        this._logicalLevelTechnique2 = _logicalLevelTechnique2;
        this._physicalLevelTechnique = _physicalLevelTechnique;
        this._numValues = _numValues;
        this._byteLength = _byteLength;
    }
    static decode(tile, offset) {
        const stream_type = tile[offset.get()];
        const physicalStreamType = Object.values(PhysicalStreamType)[stream_type >> 4];
        let logicalStreamType = null;
        switch (physicalStreamType) {
            case PhysicalStreamType.DATA:
                logicalStreamType = new LogicalStreamType(Object.values(DictionaryType)[stream_type & 0xf]);
                break;
            case PhysicalStreamType.OFFSET:
                logicalStreamType = new LogicalStreamType(null, Object.values(OffsetType)[stream_type & 0xf]);
                break;
            case PhysicalStreamType.LENGTH:
                logicalStreamType = new LogicalStreamType(null, null, Object.values(LengthType)[stream_type & 0xf]);
                break;
        }
        offset.increment();
        const encodings_header = tile[offset.get()];
        const llt1 = Object.values(LogicalLevelTechnique)[encodings_header >> 5];
        const llt2 = Object.values(LogicalLevelTechnique)[(encodings_header >> 2) & 0x7];
        const plt = Object.values(PhysicalLevelTechnique)[encodings_header & 0x3];
        offset.increment();
        const sizeInfo = decodeVarintInt32(tile, offset, 2);
        const numValues = sizeInfo[0];
        const byteLength = sizeInfo[1];
        return new StreamMetadata(physicalStreamType, logicalStreamType, llt1, llt2, plt, numValues, byteLength);
    }
    get physicalStreamType() {
        return this._physicalStreamType;
    }
    get logicalStreamType() {
        return this._logicalStreamType;
    }
    get logicalLevelTechnique1() {
        return this._logicalLevelTechnique1;
    }
    get logicalLevelTechnique2() {
        return this._logicalLevelTechnique2;
    }
    get physicalLevelTechnique() {
        return this._physicalLevelTechnique;
    }
    get numValues() {
        return this._numValues;
    }
    get byteLength() {
        return this._byteLength;
    }
    /**
     * Returns the number of decompressed values.
     * For non-RLE streams, this is the same as numValues.
     * For RLE streams, this is overridden to return numRleValues.
     */
    getDecompressedCount() {
        return this._numValues;
    }
}
//# sourceMappingURL=streamMetadata.js.map